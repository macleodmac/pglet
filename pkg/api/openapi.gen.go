//go:build go1.22

// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ExportRequestFormat.
const (
	Csv  ExportRequestFormat = "csv"
	Json ExportRequestFormat = "json"
)

// Defines values for GetTableRowsParamsSortOrder.
const (
	ASC  GetTableRowsParamsSortOrder = "ASC"
	DESC GetTableRowsParamsSortOrder = "DESC"
)

// Activity defines model for Activity.
type Activity struct {
	Application   string `json:"application"`
	ClientAddr    string `json:"client_addr"`
	Database      string `json:"database"`
	Duration      string `json:"duration"`
	Pid           int    `json:"pid"`
	Query         string `json:"query"`
	State         string `json:"state"`
	User          string `json:"user"`
	WaitEvent     string `json:"wait_event"`
	WaitEventType string `json:"wait_event_type"`
}

// AiGenerateRequest defines model for AiGenerateRequest.
type AiGenerateRequest struct {
	Database string       `json:"database"`
	Messages *[]AiMessage `json:"messages,omitempty"`
	Prompt   string       `json:"prompt"`
}

// AiGenerateResponse defines model for AiGenerateResponse.
type AiGenerateResponse struct {
	Explanation string `json:"explanation"`
	Sql         string `json:"sql"`
}

// AiMessage defines model for AiMessage.
type AiMessage struct {
	Content string `json:"content"`
	Role    string `json:"role"`
}

// AiSuggestionsResponse defines model for AiSuggestionsResponse.
type AiSuggestionsResponse struct {
	Suggestions []string `json:"suggestions"`
}

// AiTabNameRequest defines model for AiTabNameRequest.
type AiTabNameRequest struct {
	Sql string `json:"sql"`
}

// AiTabNameResponse defines model for AiTabNameResponse.
type AiTabNameResponse struct {
	Name string `json:"name"`
}

// AppInfo defines model for AppInfo.
type AppInfo struct {
	AiEnabled *bool   `json:"ai_enabled,omitempty"`
	Version   *string `json:"version,omitempty"`
}

// CancelRequest defines model for CancelRequest.
type CancelRequest struct {
	TabId string `json:"tab_id"`
}

// CellValue defines model for CellValue.
type CellValue = *string

// Column defines model for Column.
type Column struct {
	Comment      *string `json:"comment,omitempty"`
	DefaultValue *string `json:"default_value"`
	IsPrimaryKey bool    `json:"is_primary_key"`
	Name         string  `json:"name"`
	Nullable     bool    `json:"nullable"`
	Position     int     `json:"position"`
	Type         string  `json:"type"`
}

// ConnectRequest defines model for ConnectRequest.
type ConnectRequest struct {
	Url string `json:"url"`
}

// ConnectionInfo defines model for ConnectionInfo.
type ConnectionInfo struct {
	Connected *bool  `json:"connected,omitempty"`
	Database  string `json:"database"`
	Host      string `json:"host"`
	Port      int    `json:"port"`
	User      string `json:"user"`
	Version   string `json:"version"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error string `json:"error"`
}

// ExportRequest defines model for ExportRequest.
type ExportRequest struct {
	Format ExportRequestFormat `json:"format"`
	Query  string              `json:"query"`
}

// ExportRequestFormat defines model for ExportRequest.Format.
type ExportRequestFormat string

// FunctionDefinition defines model for FunctionDefinition.
type FunctionDefinition struct {
	Arguments  string `json:"arguments"`
	Definition string `json:"definition"`
	Kind       string `json:"kind"`
	Language   string `json:"language"`
	Name       string `json:"name"`
	ReturnType string `json:"return_type"`
	Schema     string `json:"schema"`
	Volatility string `json:"volatility"`
}

// HistoryEntry defines model for HistoryEntry.
type HistoryEntry struct {
	Database   string `json:"database"`
	DurationMs int64  `json:"duration_ms"`
	Error      string `json:"error"`
	ExecutedAt string `json:"executed_at"`
	Id         int    `json:"id"`
	RowCount   int    `json:"row_count"`
	Sql        string `json:"sql"`
}

// HistoryResponse defines model for HistoryResponse.
type HistoryResponse struct {
	Entries []HistoryEntry `json:"entries"`
	Total   int            `json:"total"`
}

// QueryRequest defines model for QueryRequest.
type QueryRequest struct {
	Query string `json:"query"`
	TabId string `json:"tab_id"`
}

// QueryResult defines model for QueryResult.
type QueryResult struct {
	ColumnTypes []string      `json:"column_types"`
	Columns     []string      `json:"columns"`
	DurationMs  int64         `json:"duration_ms"`
	Error       *string       `json:"error,omitempty"`
	RowCount    int           `json:"row_count"`
	Rows        [][]CellValue `json:"rows"`
}

// SavedQuery defines model for SavedQuery.
type SavedQuery struct {
	CreatedAt   string `json:"created_at"`
	Database    string `json:"database"`
	Description string `json:"description"`
	Id          string `json:"id"`
	Shared      bool   `json:"shared"`
	Sql         string `json:"sql"`
	Tags        string `json:"tags"`
	Title       string `json:"title"`
	UpdatedAt   string `json:"updated_at"`
}

// SavedQueryInput defines model for SavedQueryInput.
type SavedQueryInput struct {
	Database    *string `json:"database,omitempty"`
	Description *string `json:"description,omitempty"`
	Sql         string  `json:"sql"`
	Tags        *string `json:"tags,omitempty"`
	Title       string  `json:"title"`
}

// SchemaGroup defines model for SchemaGroup.
type SchemaGroup struct {
	Functions         []SchemaObject `json:"functions"`
	MaterializedViews []SchemaObject `json:"materialized_views"`
	Sequences         []SchemaObject `json:"sequences"`
	Tables            []SchemaObject `json:"tables"`
	Types             []SchemaObject `json:"types"`
	Views             []SchemaObject `json:"views"`
}

// SchemaObject defines model for SchemaObject.
type SchemaObject struct {
	Comment *string `json:"comment,omitempty"`
	Name    string  `json:"name"`
	Schema  string  `json:"schema"`
	Type    string  `json:"type"`
}

// SuccessResponse defines model for SuccessResponse.
type SuccessResponse struct {
	Success *bool `json:"success,omitempty"`
}

// SwitchDBRequest defines model for SwitchDBRequest.
type SwitchDBRequest struct {
	Database string `json:"database"`
}

// TabState defines model for TabState.
type TabState struct {
	// Data Opaque JSON string containing tab layout
	Data *string `json:"data,omitempty"`
}

// TableConstraint defines model for TableConstraint.
type TableConstraint struct {
	Columns    *[]string `json:"columns,omitempty"`
	Definition string    `json:"definition"`
	Name       string    `json:"name"`
	Type       string    `json:"type"`
}

// TableIndex defines model for TableIndex.
type TableIndex struct {
	Columns    *[]string `json:"columns,omitempty"`
	Definition string    `json:"definition"`
	IsPrimary  bool      `json:"is_primary"`
	IsUnique   bool      `json:"is_unique"`
	Name       string    `json:"name"`
}

// TableInfo defines model for TableInfo.
type TableInfo struct {
	IndexSize   string `json:"index_size"`
	RowEstimate int64  `json:"row_estimate"`
	TableSize   string `json:"table_size"`
	TotalSize   string `json:"total_size"`
}

// TableRowsResult defines model for TableRowsResult.
type TableRowsResult struct {
	ColumnTypes []string      `json:"column_types"`
	Columns     []string      `json:"columns"`
	Page        int           `json:"page"`
	PageSize    int           `json:"page_size"`
	Rows        [][]CellValue `json:"rows"`
	TotalCount  int           `json:"total_count"`
}

// ListHistoryParams defines parameters for ListHistory.
type ListHistoryParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListSavedQueriesParams defines parameters for ListSavedQueries.
type ListSavedQueriesParams struct {
	Database *string `form:"database,omitempty" json:"database,omitempty"`
}

// GetTableRowsParams defines parameters for GetTableRows.
type GetTableRowsParams struct {
	Limit      *int                         `form:"limit,omitempty" json:"limit,omitempty"`
	Offset     *int                         `form:"offset,omitempty" json:"offset,omitempty"`
	SortColumn *string                      `form:"sort_column,omitempty" json:"sort_column,omitempty"`
	SortOrder  *GetTableRowsParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`
}

// GetTableRowsParamsSortOrder defines parameters for GetTableRows.
type GetTableRowsParamsSortOrder string

// AiGenerateJSONRequestBody defines body for AiGenerate for application/json ContentType.
type AiGenerateJSONRequestBody = AiGenerateRequest

// AiTabNameJSONRequestBody defines body for AiTabName for application/json ContentType.
type AiTabNameJSONRequestBody = AiTabNameRequest

// AnalyzeQueryJSONRequestBody defines body for AnalyzeQuery for application/json ContentType.
type AnalyzeQueryJSONRequestBody = QueryRequest

// ConnectJSONRequestBody defines body for Connect for application/json ContentType.
type ConnectJSONRequestBody = ConnectRequest

// ExplainQueryJSONRequestBody defines body for ExplainQuery for application/json ContentType.
type ExplainQueryJSONRequestBody = QueryRequest

// ExportQueryJSONRequestBody defines body for ExportQuery for application/json ContentType.
type ExportQueryJSONRequestBody = ExportRequest

// RunQueryJSONRequestBody defines body for RunQuery for application/json ContentType.
type RunQueryJSONRequestBody = QueryRequest

// CancelQueryJSONRequestBody defines body for CancelQuery for application/json ContentType.
type CancelQueryJSONRequestBody = CancelRequest

// CreateSavedQueryJSONRequestBody defines body for CreateSavedQuery for application/json ContentType.
type CreateSavedQueryJSONRequestBody = SavedQueryInput

// UpdateSavedQueryJSONRequestBody defines body for UpdateSavedQuery for application/json ContentType.
type UpdateSavedQueryJSONRequestBody = SavedQueryInput

// SwitchDatabaseJSONRequestBody defines body for SwitchDatabase for application/json ContentType.
type SwitchDatabaseJSONRequestBody = SwitchDBRequest

// SaveTabStateJSONRequestBody defines body for SaveTabState for application/json ContentType.
type SaveTabStateJSONRequestBody = TabState

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Running queries from pg_stat_activity
	// (GET /api/activity)
	GetActivity(w http.ResponseWriter, r *http.Request)
	// Generate SQL from natural language
	// (POST /api/ai/generate)
	AiGenerate(w http.ResponseWriter, r *http.Request)
	// Generate contextual query suggestions based on connected database
	// (GET /api/ai/suggestions)
	AiSuggestions(w http.ResponseWriter, r *http.Request)
	// Generate a short tab name from SQL
	// (POST /api/ai/tab-name)
	AiTabName(w http.ResponseWriter, r *http.Request)
	// EXPLAIN ANALYZE a SQL query
	// (POST /api/analyze)
	AnalyzeQuery(w http.ResponseWriter, r *http.Request)
	// Connect to a PostgreSQL database
	// (POST /api/connect)
	Connect(w http.ResponseWriter, r *http.Request)
	// Get current connection info
	// (GET /api/connection)
	GetConnectionInfo(w http.ResponseWriter, r *http.Request)
	// List all databases on the server
	// (GET /api/databases)
	ListDatabases(w http.ResponseWriter, r *http.Request)
	// Disconnect from the database
	// (POST /api/disconnect)
	Disconnect(w http.ResponseWriter, r *http.Request)
	// EXPLAIN a SQL query
	// (POST /api/explain)
	ExplainQuery(w http.ResponseWriter, r *http.Request)
	// Export query results as CSV or JSON
	// (POST /api/export)
	ExportQuery(w http.ResponseWriter, r *http.Request)
	// Get function or procedure source code
	// (GET /api/functions/{function})
	GetFunctionDefinition(w http.ResponseWriter, r *http.Request, function string)
	// Clear all query history
	// (DELETE /api/history)
	ClearHistory(w http.ResponseWriter, r *http.Request)
	// List query history
	// (GET /api/history)
	ListHistory(w http.ResponseWriter, r *http.Request, params ListHistoryParams)
	// Get app version and feature flags
	// (GET /api/info)
	GetAppInfo(w http.ResponseWriter, r *http.Request)
	// All objects grouped by schema and type
	// (GET /api/objects)
	ListObjects(w http.ResponseWriter, r *http.Request)
	// Execute SQL query
	// (POST /api/query)
	RunQuery(w http.ResponseWriter, r *http.Request)
	// Cancel a running query
	// (POST /api/query/cancel)
	CancelQuery(w http.ResponseWriter, r *http.Request)
	// List saved queries
	// (GET /api/saved-queries)
	ListSavedQueries(w http.ResponseWriter, r *http.Request, params ListSavedQueriesParams)
	// Create a saved query
	// (POST /api/saved-queries)
	CreateSavedQuery(w http.ResponseWriter, r *http.Request)
	// Delete a saved query
	// (DELETE /api/saved-queries/{id})
	DeleteSavedQuery(w http.ResponseWriter, r *http.Request, id string)
	// Get a saved query by ID
	// (GET /api/saved-queries/{id})
	GetSavedQuery(w http.ResponseWriter, r *http.Request, id string)
	// Update a saved query
	// (PUT /api/saved-queries/{id})
	UpdateSavedQuery(w http.ResponseWriter, r *http.Request, id string)
	// List database schemas
	// (GET /api/schemas)
	ListSchemas(w http.ResponseWriter, r *http.Request)
	// PostgreSQL server settings
	// (GET /api/server_settings)
	GetServerSettings(w http.ResponseWriter, r *http.Request)
	// Switch to a different database
	// (POST /api/switchdb)
	SwitchDatabase(w http.ResponseWriter, r *http.Request)
	// Get table column definitions
	// (GET /api/tables/{table})
	GetTableColumns(w http.ResponseWriter, r *http.Request, table string)
	// Table constraints
	// (GET /api/tables/{table}/constraints)
	GetTableConstraints(w http.ResponseWriter, r *http.Request, table string)
	// Table indexes
	// (GET /api/tables/{table}/indexes)
	GetTableIndexes(w http.ResponseWriter, r *http.Request, table string)
	// Table size and row estimates
	// (GET /api/tables/{table}/info)
	GetTableInfo(w http.ResponseWriter, r *http.Request, table string)
	// Paginated table data
	// (GET /api/tables/{table}/rows)
	GetTableRows(w http.ResponseWriter, r *http.Request, table string, params GetTableRowsParams)
	// All tables size and row stats
	// (GET /api/tables_stats)
	GetTablesStats(w http.ResponseWriter, r *http.Request)
	// Get persisted tab state
	// (GET /api/tabs)
	GetTabState(w http.ResponseWriter, r *http.Request)
	// Save tab state
	// (PUT /api/tabs)
	SaveTabState(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetActivity operation middleware
func (siw *ServerInterfaceWrapper) GetActivity(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetActivity(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AiGenerate operation middleware
func (siw *ServerInterfaceWrapper) AiGenerate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AiGenerate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AiSuggestions operation middleware
func (siw *ServerInterfaceWrapper) AiSuggestions(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AiSuggestions(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AiTabName operation middleware
func (siw *ServerInterfaceWrapper) AiTabName(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AiTabName(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AnalyzeQuery operation middleware
func (siw *ServerInterfaceWrapper) AnalyzeQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AnalyzeQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Connect operation middleware
func (siw *ServerInterfaceWrapper) Connect(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Connect(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetConnectionInfo operation middleware
func (siw *ServerInterfaceWrapper) GetConnectionInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConnectionInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDatabases operation middleware
func (siw *ServerInterfaceWrapper) ListDatabases(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDatabases(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// Disconnect operation middleware
func (siw *ServerInterfaceWrapper) Disconnect(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Disconnect(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExplainQuery operation middleware
func (siw *ServerInterfaceWrapper) ExplainQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExplainQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ExportQuery operation middleware
func (siw *ServerInterfaceWrapper) ExportQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ExportQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFunctionDefinition operation middleware
func (siw *ServerInterfaceWrapper) GetFunctionDefinition(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "function" -------------
	var function string

	err = runtime.BindStyledParameterWithOptions("simple", "function", r.PathValue("function"), &function, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "function", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFunctionDefinition(w, r, function)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClearHistory operation middleware
func (siw *ServerInterfaceWrapper) ClearHistory(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClearHistory(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListHistory operation middleware
func (siw *ServerInterfaceWrapper) ListHistory(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListHistoryParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListHistory(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetAppInfo operation middleware
func (siw *ServerInterfaceWrapper) GetAppInfo(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAppInfo(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListObjects operation middleware
func (siw *ServerInterfaceWrapper) ListObjects(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListObjects(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RunQuery operation middleware
func (siw *ServerInterfaceWrapper) RunQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RunQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelQuery operation middleware
func (siw *ServerInterfaceWrapper) CancelQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSavedQueries operation middleware
func (siw *ServerInterfaceWrapper) ListSavedQueries(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSavedQueriesParams

	// ------------- Optional query parameter "database" -------------

	err = runtime.BindQueryParameter("form", true, false, "database", r.URL.Query(), &params.Database)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "database", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSavedQueries(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateSavedQuery operation middleware
func (siw *ServerInterfaceWrapper) CreateSavedQuery(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateSavedQuery(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteSavedQuery operation middleware
func (siw *ServerInterfaceWrapper) DeleteSavedQuery(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteSavedQuery(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetSavedQuery operation middleware
func (siw *ServerInterfaceWrapper) GetSavedQuery(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSavedQuery(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateSavedQuery operation middleware
func (siw *ServerInterfaceWrapper) UpdateSavedQuery(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateSavedQuery(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListSchemas operation middleware
func (siw *ServerInterfaceWrapper) ListSchemas(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSchemas(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetServerSettings operation middleware
func (siw *ServerInterfaceWrapper) GetServerSettings(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetServerSettings(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SwitchDatabase operation middleware
func (siw *ServerInterfaceWrapper) SwitchDatabase(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SwitchDatabase(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTableColumns operation middleware
func (siw *ServerInterfaceWrapper) GetTableColumns(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "table" -------------
	var table string

	err = runtime.BindStyledParameterWithOptions("simple", "table", r.PathValue("table"), &table, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTableColumns(w, r, table)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTableConstraints operation middleware
func (siw *ServerInterfaceWrapper) GetTableConstraints(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "table" -------------
	var table string

	err = runtime.BindStyledParameterWithOptions("simple", "table", r.PathValue("table"), &table, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTableConstraints(w, r, table)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTableIndexes operation middleware
func (siw *ServerInterfaceWrapper) GetTableIndexes(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "table" -------------
	var table string

	err = runtime.BindStyledParameterWithOptions("simple", "table", r.PathValue("table"), &table, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTableIndexes(w, r, table)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTableInfo operation middleware
func (siw *ServerInterfaceWrapper) GetTableInfo(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "table" -------------
	var table string

	err = runtime.BindStyledParameterWithOptions("simple", "table", r.PathValue("table"), &table, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTableInfo(w, r, table)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTableRows operation middleware
func (siw *ServerInterfaceWrapper) GetTableRows(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "table" -------------
	var table string

	err = runtime.BindStyledParameterWithOptions("simple", "table", r.PathValue("table"), &table, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "table", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTableRowsParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_column" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_column", r.URL.Query(), &params.SortColumn)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_column", Err: err})
		return
	}

	// ------------- Optional query parameter "sort_order" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort_order", r.URL.Query(), &params.SortOrder)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sort_order", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTableRows(w, r, table, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTablesStats operation middleware
func (siw *ServerInterfaceWrapper) GetTablesStats(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTablesStats(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetTabState operation middleware
func (siw *ServerInterfaceWrapper) GetTabState(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetTabState(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SaveTabState operation middleware
func (siw *ServerInterfaceWrapper) SaveTabState(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SaveTabState(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/api/activity", wrapper.GetActivity)
	m.HandleFunc("POST "+options.BaseURL+"/api/ai/generate", wrapper.AiGenerate)
	m.HandleFunc("GET "+options.BaseURL+"/api/ai/suggestions", wrapper.AiSuggestions)
	m.HandleFunc("POST "+options.BaseURL+"/api/ai/tab-name", wrapper.AiTabName)
	m.HandleFunc("POST "+options.BaseURL+"/api/analyze", wrapper.AnalyzeQuery)
	m.HandleFunc("POST "+options.BaseURL+"/api/connect", wrapper.Connect)
	m.HandleFunc("GET "+options.BaseURL+"/api/connection", wrapper.GetConnectionInfo)
	m.HandleFunc("GET "+options.BaseURL+"/api/databases", wrapper.ListDatabases)
	m.HandleFunc("POST "+options.BaseURL+"/api/disconnect", wrapper.Disconnect)
	m.HandleFunc("POST "+options.BaseURL+"/api/explain", wrapper.ExplainQuery)
	m.HandleFunc("POST "+options.BaseURL+"/api/export", wrapper.ExportQuery)
	m.HandleFunc("GET "+options.BaseURL+"/api/functions/{function}", wrapper.GetFunctionDefinition)
	m.HandleFunc("DELETE "+options.BaseURL+"/api/history", wrapper.ClearHistory)
	m.HandleFunc("GET "+options.BaseURL+"/api/history", wrapper.ListHistory)
	m.HandleFunc("GET "+options.BaseURL+"/api/info", wrapper.GetAppInfo)
	m.HandleFunc("GET "+options.BaseURL+"/api/objects", wrapper.ListObjects)
	m.HandleFunc("POST "+options.BaseURL+"/api/query", wrapper.RunQuery)
	m.HandleFunc("POST "+options.BaseURL+"/api/query/cancel", wrapper.CancelQuery)
	m.HandleFunc("GET "+options.BaseURL+"/api/saved-queries", wrapper.ListSavedQueries)
	m.HandleFunc("POST "+options.BaseURL+"/api/saved-queries", wrapper.CreateSavedQuery)
	m.HandleFunc("DELETE "+options.BaseURL+"/api/saved-queries/{id}", wrapper.DeleteSavedQuery)
	m.HandleFunc("GET "+options.BaseURL+"/api/saved-queries/{id}", wrapper.GetSavedQuery)
	m.HandleFunc("PUT "+options.BaseURL+"/api/saved-queries/{id}", wrapper.UpdateSavedQuery)
	m.HandleFunc("GET "+options.BaseURL+"/api/schemas", wrapper.ListSchemas)
	m.HandleFunc("GET "+options.BaseURL+"/api/server_settings", wrapper.GetServerSettings)
	m.HandleFunc("POST "+options.BaseURL+"/api/switchdb", wrapper.SwitchDatabase)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables/{table}", wrapper.GetTableColumns)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables/{table}/constraints", wrapper.GetTableConstraints)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables/{table}/indexes", wrapper.GetTableIndexes)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables/{table}/info", wrapper.GetTableInfo)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables/{table}/rows", wrapper.GetTableRows)
	m.HandleFunc("GET "+options.BaseURL+"/api/tables_stats", wrapper.GetTablesStats)
	m.HandleFunc("GET "+options.BaseURL+"/api/tabs", wrapper.GetTabState)
	m.HandleFunc("PUT "+options.BaseURL+"/api/tabs", wrapper.SaveTabState)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"psLEh2632/0vAAD//wDZEy1oSAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
